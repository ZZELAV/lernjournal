---
title: "Tag 13"
tags:
  - M141
  - Tag 13
  - MongoDB
  - Design
  - Schema
  - Indexierung
  - Cluster
---

# Tag 13

## 1 Dokumentationsaufträge

### 1.1 Dokumentieren Sie die wichtigsten Regeln für das Datenbankdesign bei MongoDB. Erläutern Sie bei Bedarf die Regeln mit einem Beispiel

#### 1.1.1 Relational vs. Schemaless

Bei relationalen Datenbanken werden Informationen mittels SQL Joins geholt. Da MongoDB allerdings mit Documents und nicht mit Tabellen arbeitet, muss dieses Schema mittels Arrays und Nested Documents abgebildet werden.

```json
{
  "first_name": "Paul",
  "surname": "Miller",
  "cell": "447557505611",
  "city": "London",
  "location": [45.123, 47.232],
  "profession": ["banking", "finance", "trader"],
  "cars": [
    {
      "model": "Bentley",
      "year": 1973
    },
    {
      "model": "Rolls Royce",
      "year": 1965
    }
  ]
}
```

:::tip MERKE

Anstatt Daten in verschiedene Tabellen aufzusplitten, nutzen wir Arrays und Nested Documents um Informationen strukturiert abbilden zu können.

**Wichtig: in diesem Fall keine separaten Collections erstellen**

:::

#### 1.1.2 Embedding vs. Referencing

Um bei MongoDB FKs und PKs zu erzwingen, muss das `Referencing` mittels des Operators `$lookup` genutzt werden. `$lookup` kann mit einem `LEFT OUTER JOIN` verglichen werden.

##### Beispiel

Collection `order` erstellen:

```mongodb
db.orders.insertMany( [
   { "_id" : 1, "item" : "almonds", "price" : 12, "quantity" : 2 },
   { "_id" : 2, "item" : "pecans", "price" : 20, "quantity" : 1 },
   { "_id" : 3  }
] )
```

Collection `inventory` erstellen:

```mongodb
db.inventory.insertMany( [
   { "_id" : 1, "sku" : "almonds", "description": "product 1", "instock" : 120 },
   { "_id" : 2, "sku" : "bread", "description": "product 2", "instock" : 80 },
   { "_id" : 3, "sku" : "cashews", "description": "product 3", "instock" : 60 },
   { "_id" : 4, "sku" : "pecans", "description": "product 4", "instock" : 70 },
   { "_id" : 5, "sku": null, "description": "Incomplete" },
   { "_id" : 6 }
] )
```

Die Collections verknüpfen (referenzieren):

```mongodb
db.orders.aggregate( [
   {
     $lookup:
       {
         from: "inventory",
         localField: "item",
         foreignField: "sku",
         as: "inventory_docs"
       }
  }
] )
```

```mongodb title="OUTPUT"
{
   "_id" : 1,
   "item" : "almonds",
   "price" : 12,
   "quantity" : 2,
   "inventory_docs" : [
      { "_id" : 1, "sku" : "almonds", "description" : "product 1", "instock" : 120 }
   ]
}
{
   "_id" : 2,
   "item" : "pecans",
   "price" : 20,
   "quantity" : 1,
   "inventory_docs" : [
      { "_id" : 4, "sku" : "pecans", "description" : "product 4", "instock" : 70 }
   ]
}
{
   "_id" : 3,
   "inventory_docs" : [
      { "_id" : 5, "sku" : null, "description" : "Incomplete" },
      { "_id" : 6 }
   ]
}
```

[Weitere Informationen](https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/)

##### Vor- und Nachteile Referencing

**Vorteile**:

- Kleinere Documents
- Documents können kleiner als 16MB gehalten werden (Limit von BSON)
- Nützlich wenn nicht alle Daten oft aufgerufen werden müssen
- Weniger Redundanzen in den Informationen

**Nachteile**:

- Komplizierte Abfragen

##### Vor- und Nachteile Embedding

**Vorteile**:

- Eine Query = alle Daten laden
- Keine Joins
- CRUD-Operationen sind ACID-fähig

**Nachteile**:

- Query auf grosse Documents kann (bei doppelten Daten) die Performance beeinflussen
